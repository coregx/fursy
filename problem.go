// Copyright 2025 coregx. All rights reserved.
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file.

package fursy

import (
	"encoding/json"
	"fmt"
)

// Problem represents an RFC 9457 Problem Details object.
//
// RFC 9457 defines a "problem detail" as a way to carry machine-readable
// details of errors in HTTP response content to avoid the need to define
// new error response formats for HTTP APIs.
//
// Standard fields:
//   - type: URI reference identifying the problem type
//   - title: Short, human-readable summary
//   - status: HTTP status code
//   - detail: Human-readable explanation specific to this occurrence
//   - instance: URI reference to the specific occurrence
//
// Extensions can be added via the Extensions map, which will be flattened
// into the JSON output.
//
// Example:
//
//	problem := fursy.Problem{
//	    Type:   "https://example.com/probs/out-of-credit",
//	    Title:  "You do not have enough credit",
//	    Status: 403,
//	    Detail: "Your current balance is 30, but that costs 50",
//	    Instance: "/account/12345/msgs/abc",
//	}
//
// Media Type: application/problem+json
//
// Spec: https://www.rfc-editor.org/rfc/rfc9457.html
//
//nolint:errname // "Problem" is the official RFC 9457 naming, not "ProblemError"
type Problem struct {
	// Type is a URI reference that identifies the problem type.
	// It should provide human-readable documentation for the problem type.
	// When dereferenced, it SHOULD provide human-readable documentation.
	// Defaults to "about:blank" if not specified.
	Type string `json:"type"`

	// Title is a short, human-readable summary of the problem type.
	// It SHOULD NOT change from occurrence to occurrence of the problem,
	// except for purposes of localization.
	Title string `json:"title"`

	// Status is the HTTP status code generated by the origin server.
	Status int `json:"status"`

	// Detail is a human-readable explanation specific to this occurrence.
	// It SHOULD focus on helping the client correct the problem.
	Detail string `json:"detail,omitempty"`

	// Instance is a URI reference that identifies the specific occurrence.
	// It may or may not yield further information if dereferenced.
	Instance string `json:"instance,omitempty"`

	// Extensions contains additional problem-specific fields.
	// These will be flattened into the JSON output alongside standard fields.
	//
	// Example:
	//   Extensions: map[string]any{
	//       "balance": 30,
	//       "cost": 50,
	//   }
	Extensions map[string]any `json:"-"`
}

// Error implements the error interface.
// Returns the detail if available, otherwise the title.
func (p Problem) Error() string {
	if p.Detail != "" {
		return p.Detail
	}
	return p.Title
}

// MarshalJSON implements custom JSON marshaling to flatten extensions.
func (p Problem) MarshalJSON() ([]byte, error) {
	// Create a map with all standard fields.
	m := map[string]any{
		"type":   p.Type,
		"title":  p.Title,
		"status": p.Status,
	}

	// Add optional fields if present.
	if p.Detail != "" {
		m["detail"] = p.Detail
	}
	if p.Instance != "" {
		m["instance"] = p.Instance
	}

	// Flatten extensions into the map.
	for k, v := range p.Extensions {
		// Prevent overwriting standard fields.
		if k != "type" && k != "title" && k != "status" && k != "detail" && k != "instance" {
			m[k] = v
		}
	}

	return json.Marshal(m)
}

// NewProblem creates a new Problem with the given status, title, and detail.
// The type defaults to "about:blank" as per RFC 9457.
func NewProblem(status int, title, detail string) Problem {
	return Problem{
		Type:   "about:blank",
		Title:  title,
		Status: status,
		Detail: detail,
	}
}

// WithType sets the type URI for the problem.
func (p Problem) WithType(typeURI string) Problem {
	p.Type = typeURI
	return p
}

// WithInstance sets the instance URI for the problem.
func (p Problem) WithInstance(instance string) Problem {
	p.Instance = instance
	return p
}

// WithExtension adds an extension field to the problem.
func (p Problem) WithExtension(key string, value any) Problem {
	if p.Extensions == nil {
		p.Extensions = make(map[string]any)
	}
	p.Extensions[key] = value
	return p
}

// WithExtensions sets multiple extension fields at once.
func (p Problem) WithExtensions(extensions map[string]any) Problem {
	if p.Extensions == nil {
		p.Extensions = make(map[string]any)
	}
	for k, v := range extensions {
		p.Extensions[k] = v
	}
	return p
}

// Standard Problem constructors for common HTTP errors.

// BadRequest creates a 400 Bad Request problem.
func BadRequest(detail string) Problem {
	return NewProblem(400, "Bad Request", detail)
}

// Unauthorized creates a 401 Unauthorized problem.
func Unauthorized(detail string) Problem {
	return NewProblem(401, "Unauthorized", detail)
}

// Forbidden creates a 403 Forbidden problem.
func Forbidden(detail string) Problem {
	return NewProblem(403, "Forbidden", detail)
}

// NotFound creates a 404 Not Found problem.
func NotFound(detail string) Problem {
	return NewProblem(404, "Not Found", detail)
}

// MethodNotAllowed creates a 405 Method Not Allowed problem.
func MethodNotAllowed(detail string) Problem {
	return NewProblem(405, "Method Not Allowed", detail)
}

// Conflict creates a 409 Conflict problem.
func Conflict(detail string) Problem {
	return NewProblem(409, "Conflict", detail)
}

// UnprocessableEntity creates a 422 Unprocessable Entity problem.
// This is commonly used for validation errors.
func UnprocessableEntity(detail string) Problem {
	return NewProblem(422, "Unprocessable Entity", detail)
}

// TooManyRequests creates a 429 Too Many Requests problem.
func TooManyRequests(detail string) Problem {
	return NewProblem(429, "Too Many Requests", detail)
}

// InternalServerError creates a 500 Internal Server Error problem.
func InternalServerError(detail string) Problem {
	return NewProblem(500, "Internal Server Error", detail)
}

// ServiceUnavailable creates a 503 Service Unavailable problem.
func ServiceUnavailable(detail string) Problem {
	return NewProblem(503, "Service Unavailable", detail)
}

// ValidationProblem creates a 422 Unprocessable Entity problem from ValidationErrors.
//
// The validation errors are included as an extension field "errors" containing
// a map of field names to error messages.
//
// Example output:
//
//	{
//	  "type": "about:blank",
//	  "title": "Validation Failed",
//	  "status": 422,
//	  "detail": "One or more fields failed validation",
//	  "errors": {
//	    "email": "must be a valid email address",
//	    "age": "must be at least 18"
//	  }
//	}
func ValidationProblem(errs ValidationErrors) Problem {
	if errs.IsEmpty() {
		return UnprocessableEntity("validation failed")
	}

	detail := fmt.Sprintf("%d field(s) failed validation", len(errs))
	if len(errs) == 1 {
		detail = errs[0].Message
	}

	return Problem{
		Type:   "about:blank",
		Title:  "Validation Failed",
		Status: 422,
		Detail: detail,
		Extensions: map[string]any{
			"errors": errs.Fields(),
		},
	}
}
